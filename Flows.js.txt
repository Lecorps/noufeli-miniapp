/**
 * flows.js  â€“  Telegram bot conversation flows
 * All data operations go through convex.gs helpers (db* functions).
 */


// Life areas match Convex schema literals exactly
var LIFE_AREAS = ['spiritual','physical','mental','financial','social','emotional'];
var LIFE_AREA_LABELS = {
  spiritual: 'Spiritual âœï¸', physical: 'Physical ğŸ’ª', mental: 'Mental ğŸ§ ',
  financial: 'Financial ğŸ’°', social: 'Social ğŸ‘¥', emotional: 'Emotional â¤ï¸'
};
var HORIZONS      = ['today','week','month','quarter','annum','someday'];
var INCUP_OPTIONS = ['Interesting','Novel','Challenging','Urgent','Pressure/Passion'];
var CATEGORIES    = ['main-quest','side-quest','fake-boss','sleeping-dragon','void-filler'];
var EXE_TYPES     = ['task','project','habit'];
var EMOTIONS      = ['joyful','excited','hopeful','calm','curious','neutral','bored','anxious','frustrated','overwhelmed','defeated'];


// â”€â”€â”€ State helpers (backed by Convex user.settings.botState) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function getState(telegramId) {
  return dbGetState(telegramId) || {};
}


function setState(telegramId, state) {
  dbSetState(telegramId, state);
}


function clearState(telegramId) {
  dbClearState(telegramId);
}


function setWaiting(telegramId, waiting) {
  const state = getState(telegramId);
  state.waiting4Reply = !!waiting;
  setState(telegramId, state);
}


function isWaiting(telegramId) {
  const state = getState(telegramId);
  return !!(state && state.waiting4Reply);
}


// â”€â”€â”€ /start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleStart(msg) {
  const chatId     = msg.chat.id;
  const telegramId = String(msg.from.id);
  const name       = msg.from.first_name || 'Adventurer';


  // Upsert user in Convex and save chatId
  const convexUserId = dbEnsureUser(telegramId, msg.from.first_name, msg.from.last_name, msg.from.username);
  convexMutation('users:setUserSettings', { telegramId: telegramId, chatId: String(chatId) });


  // Don't restart if mid-setup
  const existing = getState(telegramId);
  if (existing && existing.flow) {
    sendMessage(chatId,
      'â³ You\'re already in the middle of setup, ' + name + '\n\n' +
      'Please answer the current question to continue, or send /reset to start over.'
    );
    return;
  }


  setState(telegramId, { flow: 'onboarding', convexUserId: convexUserId });


  sendMessage(chatId,
    'âš”ï¸ Welcome to <b>Noufeli</b>, ' + name + '!\n\n' +
    'I turn your captured thoughts into an epic quest system.\n\n' +
    'How would you like to start?',
    inlineButtons([[
      { text: 'Help me set goals',  callback_data: 'SETUP_GUIDE:start' },
      { text: 'Add goals manually', callback_data: 'SETUP_GUIDE:manual' }
    ]])
  );
}


function handleSetupGuide(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const data       = cq.data;


  convexMutation('users:setUserSettings', { telegramId: telegramId, chatId: String(chatId) });


  const state = getState(telegramId);
  const convexUserId = state.convexUserId || dbEnsureUser(telegramId);


  if (data === 'SETUP_GUIDE:manual') {
    editMessage(chatId, cq.message.message_id,
      'âš”ï¸ Welcome to <b>Noufeli</b>!\n\nâœ… Manual setup selected.'
    );
    setState(telegramId, { flow: 'manual_goals', step: 'waiting', convexUserId: convexUserId });
    setWaiting(telegramId, true);
    sendMessage(chatId,
      'ğŸ“‹ <b>Set up your goals</b>\n\n' +
      'Copy the format below and fill in your goal for each life area, then send it back to me:\n\n' +
      '<pre>' +
      'Spiritual: \n' +
      'Physical: \n' +
      'Mental: \n' +
      'Financial: \n' +
      'Social: \n' +
      'Emotional: ' +
      '</pre>'
    );
    return;
  }


  if (data === 'SETUP_GUIDE:start') {
    editMessage(chatId, cq.message.message_id,
      'âš”ï¸ Welcome to <b>Noufeli</b>!\n\nâœ… Guided setup selected.'
    );
    setState(telegramId, { flow: 'gap_analysis', areaIndex: 0, step: 'ideal', areaData: {}, convexUserId: convexUserId });
    askGapAnalysisQuestion(chatId, telegramId);
    return;
  }


  if (data.startsWith('SETUP_GUIDE:interval:')) {
    const minutes = parseInt(data.split(':')[2]);


    // Guard duplicate delivery
    const user = dbGetUser(telegramId);
    if (user && user.settings && user.settings.organizeIntervalMinutes > 0) {
      Logger.log('Duplicate interval callback for ' + telegramId + ' â€“ ignoring.');
      return;
    }


    dbSetOrganizeInterval(telegramId, minutes);
    // Stamp lastOrganizedAt now so the reminder timer starts from this moment
    // rather than immediately re-firing after onboarding completes.
    dbMarkOrganizeDone(telegramId);


    editMessage(chatId, cq.message.message_id,
      'How often should I remind you to organise captured activities?\n\n' +
      'âœ… <b>' + (minutes === 90 ? '90 min' : minutes === 120 ? '2 hours' : '4 hours') + '</b> selected.'
    );
    sendMessage(chatId,
      'âœ… Got it! I\'ll remind you every ' + (minutes >= 60 ? (minutes / 60) + ' hour(s)' : minutes + ' min') + '.\n\n' +
      'You\'re all set! Forward me any message to capture it as a task. ğŸš€'
    );
    clearState(telegramId);
    return;
  }
}


// â”€â”€â”€ /reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleReset(msg) {
  const chatId     = msg.chat.id;
  const telegramId = String(msg.from.id);
  // Ensure user exists before writing state, so setUserSettings doesn't throw.
  dbEnsureUser(telegramId, msg.from.first_name, msg.from.last_name, msg.from.username);
  dbClearState(telegramId);
  sendMessage(chatId,
    'ğŸ”„ State cleared! Send /start to begin setup again, or just forward a message to capture a task.'
  );
}


// â”€â”€â”€ Manual goals entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleManualGoalsReply(chatId, telegramId, text, state) {
  const lines  = text.split('\n');
  const saved   = [];
  const skipped = [];


  const areaMap = {
    'spiritual': 'spiritual', 'physical': 'physical', 'mental': 'mental',
    'financial': 'financial', 'social': 'social',     'emotional': 'emotional'
  };


  const goalsToCreate = [];
  lines.forEach(function(line) {
    const colonIdx = line.indexOf(':');
    if (colonIdx < 0) return;
    const rawArea = line.substring(0, colonIdx).trim().toLowerCase();
    const goal    = line.substring(colonIdx + 1).trim();
    const area    = areaMap[rawArea];
    if (!area) return;
    if (!goal) { skipped.push(rawArea); return; }
    goalsToCreate.push({ title: goal, lifeArea: area, horizon: 'annum', category: 'main-quest' });
    saved.push('âœ… <b>' + rawArea.charAt(0).toUpperCase() + rawArea.slice(1) + ':</b> ' + goal);
  });


  if (saved.length === 0) {
    sendMessage(chatId,
      'âš ï¸ I couldn\'t read any goals. Use the format below â€” each line needs the area name followed by a colon:\n\n' +
      '<pre>Health: your goal here\nWealth: your goal here</pre>'
    );
    return;
  }


  // Batch create goals in Convex
  dbCreateGoalsFromGapAnalysis(state.convexUserId, goalsToCreate);


  var summary = 'ğŸ† <b>Goals saved!</b>\n\n' + saved.join('\n');
  if (skipped.length > 0) summary += '\n\nâ­ï¸ Skipped (blank): ' + skipped.join(', ');
  sendMessage(chatId, summary);


  setState(telegramId, { flow: 'onboarding', step: 'interval', convexUserId: state.convexUserId });
  setWaiting(telegramId, true);
  sendMessage(chatId,
    'Almost done! How often should I remind you to organise captured activities?',
    inlineButtons([[
      { text: '90 min',  callback_data: 'SETUP_GUIDE:interval:90' },
      { text: '2 hours', callback_data: 'SETUP_GUIDE:interval:120' },
      { text: '4 hours', callback_data: 'SETUP_GUIDE:interval:240' }
    ]])
  );
}


// â”€â”€â”€ Gap analysis wizard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function askGapAnalysisQuestion(chatId, telegramId) {
  const state = getState(telegramId);
  const area  = LIFE_AREAS[state.areaIndex];


  if (!area) {
    deriveGoalsFromGapAnalysis(chatId, telegramId);
    return;
  }
  if (isWaiting(telegramId)) return;


  const label = LIFE_AREA_LABELS[area] || area;
  const stepTexts = {
    ideal:    'In your <b>' + label + '</b> life area, describe your <b>ideal</b> state:',
    current:  'What is your <b>current</b> state in ' + label + '?',
    obstacle: 'What are the main <b>obstacles</b> stopping you?'
  };


  sendMessage(chatId, stepTexts[state.step] || 'Tell me more:');
  setWaiting(telegramId, true);
}


function handleConversationState(msg) {
  const chatId     = msg.chat.id;
  const telegramId = String(msg.from.id);
  const text       = msg.text || '';
  const state      = getState(telegramId);


  if (!state || !state.flow) return;


  if (state.flow === 'gap_analysis')  { handleGapAnalysisReply(chatId, telegramId, text, state); return; }
  if (state.flow === 'manual_goals')  { handleManualGoalsReply(chatId, telegramId, text, state); return; }
  if (state.flow === 'organise')      { handleOrganiseTextReply(chatId, telegramId, text, state, msg); return; }
  if (state.flow === 'habit_create')  { handleHabitCreateReply(chatId, telegramId, text, state); return; }
}


function handleGapAnalysisReply(chatId, telegramId, text, state) {
  const area = LIFE_AREAS[state.areaIndex];
  if (!state.areaData) state.areaData = {};
  if (!state.areaData[area]) state.areaData[area] = {};


  setWaiting(telegramId, false);
  state.areaData[area][state.step] = text;


  if (state.step === 'ideal')        state.step = 'current';
  else if (state.step === 'current') state.step = 'obstacle';
  else { state.areaIndex++; state.step = 'ideal'; }


  setState(telegramId, state);
  askGapAnalysisQuestion(chatId, telegramId);
}


function deriveGoalsFromGapAnalysis(chatId, telegramId) {
  const state    = getState(telegramId);
  const areaData = state.areaData || {};
  const goalsToCreate = [];


  LIFE_AREAS.forEach(function(area) {
    const d = areaData[area];
    if (!d || !d.ideal) return;
    goalsToCreate.push({
      title:    'Reach ideal ' + area + ': ' + d.ideal.substring(0, 80),
      lifeArea: area, horizon: 'annum', category: 'main-quest'
    });
    if (d.obstacle && d.obstacle.length > 20) {
      goalsToCreate.push({
        title:    'Overcome ' + area + ' obstacle: ' + d.obstacle.substring(0, 80),
        lifeArea: area, horizon: 'quarter', category: 'sleeping-dragon'
      });
    }
  });


  const created = dbCreateGoalsFromGapAnalysis(state.convexUserId, goalsToCreate);


  sendMessage(chatId,
    'ğŸ† Gap analysis complete! Created <b>' + goalsToCreate.length + '</b> goals.\n\n' +
    'How often should I remind you to organise captured activities?',
    inlineButtons([[
      { text: '90 min',  callback_data: 'SETUP_GUIDE:interval:90' },
      { text: '2 hours', callback_data: 'SETUP_GUIDE:interval:120' },
      { text: '4 hours', callback_data: 'SETUP_GUIDE:interval:240' }
    ]])
  );
  setState(telegramId, { flow: 'onboarding', step: 'interval', convexUserId: state.convexUserId });
  setWaiting(telegramId, true);
}


// â”€â”€â”€ Capture (forwarded messages) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleForwardedMessage(msg) {
  const chatId     = msg.chat.id;
  const telegramId = String(msg.from.id);


  var text = msg.text || msg.caption || '';
  if (msg.forward_origin && msg.forward_origin.type === 'channel') {
    text = text || '[Channel post]';
  }


  var link = '';
  if (msg.forward_from_chat && msg.forward_from_message_id) {
    link = 'https://t.me/c/' + String(msg.forward_from_chat.id).replace('-100','') + '/' + msg.forward_from_message_id;
  }


  // Ensure user exists and get their Convex ID
  const convexUserId = dbEnsureUser(telegramId, msg.from.first_name, msg.from.last_name, msg.from.username);


  const result = dbCaptureActivity(convexUserId, text, link || undefined);


  sendMessage(chatId,
    'âš¡ <b>Captured!</b>\n\n' +
    'ğŸ“‹ <code>' + result.activityId + '</code>\n' +
    'ğŸ“ ' + text.substring(0, 80) + (text.length > 80 ? 'â€¦' : '') + '\n' +
    'âœ¨ +' + result.captureXp + ' CaptureXP\n\n' +
    'Forward more or use /organise when ready!'
  );
}


// â”€â”€â”€ Organise flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function triggerOrganiseReminder(telegramId, chatId) {
  const state = getState(telegramId);
  if (state && state.flow) return; // mid-conversation


  const convexUserId = dbEnsureUser(telegramId);
  const captured = dbListCaptured(convexUserId);
  if (!captured || captured.length === 0) return;


  sendMessage(chatId,
    'ğŸ“¬ You have <b>' + captured.length + '</b> captured activities to organise.\n\nWhich order?',
    inlineButtons([[
      { text: 'â° First â†’ Last', callback_data: 'ORG_ORDER:asc' },
      { text: 'ğŸ”„ Last â†’ First', callback_data: 'ORG_ORDER:desc' }
    ]])
  );
}


function handleOrganizeOrder(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const order      = cq.data.split(':')[1];


  const state        = getState(telegramId);
  const convexUserId = state.convexUserId || dbEnsureUser(telegramId);


  var captured = dbListCaptured(convexUserId);
  if (!captured || captured.length === 0) {
    sendMessage(chatId, 'âœ… Nothing to organise right now!');
    return;
  }
  if (order === 'desc') captured = captured.reverse();


  // Store queue as array of Convex _id strings
  setState(telegramId, {
    flow: 'organise',
    convexUserId: convexUserId,
    queue: captured.map(function(a) { return { id: a._id, activityId: a.activityId, activity: a.activity }; }),
    qIndex: 0
  });
  presentOrganiseItem(chatId, telegramId);
}


function presentOrganiseItem(chatId, telegramId) {
  const state = getState(telegramId);
  if (state.qIndex >= state.queue.length) {
    finishOrganise(chatId, telegramId);
    return;
  }
  if (isWaiting(telegramId)) return;


  const item  = state.queue[state.qIndex];
  const goals = dbListGoals(state.convexUserId) || [];
  const goalList = goals.length > 0
    ? goals.map(function(g, i) { return (i+1) + '. ' + g.title + ' [' + g.goalId + ']'; }).join('\n')
    : 'No goals yet â€” reply <code>0</code> to skip';


  sendMessage(chatId,
    'ğŸ—‚ï¸ <b>Organising ' + (state.qIndex+1) + '/' + state.queue.length + '</b>\n\n' +
    'ğŸ“ ' + item.activity + '\n\n' +
    '<b>Step 1/7:</b> Which goal does this belong to?\n\n' + goalList +
    '\n\nReply with a number (e.g. <code>1</code>), or <code>0</code> to skip:'
  );
  state.step = 'goal';
  state.goals = goals; // cache for this session
  setState(telegramId, state);
  setWaiting(telegramId, true);
}


function handleOrganiseTextReply(chatId, telegramId, text, state, msg) {
  if (state.step !== 'goal') return;
  setWaiting(telegramId, false);


  const goals   = state.goals || [];
  const idx     = parseInt(text.trim()) - 1;
  const goal    = (idx >= 0 && goals[idx]) ? goals[idx] : null;


  state.pendingGoalId = goal ? goal.goalId : undefined;
  setState(telegramId, state);
  askOrganiseStep(chatId, telegramId, 'incup');
}


function handleOrganizeGoal(cq) {} // handled via text reply


function handleOrganizeIncup(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const state      = getState(telegramId);


  setWaiting(telegramId, false);
  const tag = cq.data.replace('ORG_INCUP:','');
  if (!state.incupSelected) state.incupSelected = [];


  if (tag === 'DONE') {
    state.pendingIncup = state.incupSelected.join('');
    delete state.incupSelected;
    setState(telegramId, state);
    askOrganiseStep(chatId, telegramId, 'area');
    return;
  }


  const idx = state.incupSelected.indexOf(tag);
  if (idx >= 0) state.incupSelected.splice(idx, 1); else state.incupSelected.push(tag);
  setState(telegramId, state);


  const buttons = INCUP_OPTIONS.map(function(opt) {
    const sel = state.incupSelected.indexOf(opt) >= 0 ? 'âœ… ' : '';
    return [{ text: sel + opt, callback_data: 'ORG_INCUP:' + opt }];
  });
  buttons.push([{ text: 'âœ”ï¸ Done', callback_data: 'ORG_INCUP:DONE' }]);
  editMessage(chatId, cq.message.message_id,
    'ğŸ—‚ï¸ <b>Step 2/7:</b> INCUP tags (tap to toggle):',
    { reply_markup: { inline_keyboard: buttons } }
  );
  setWaiting(telegramId, true);
}


function handleOrganizeArea(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const state      = getState(telegramId);


  setWaiting(telegramId, false);


  // Habit create flow uses 'ORG_AREA:habit:<area>' to share the same prefix
  if (cq.data.startsWith('ORG_AREA:habit:')) {
    const area = cq.data.replace('ORG_AREA:habit:', '');
    state.habitLifeArea = area;
    state.step = 'variants';
    setState(telegramId, state);
    sendMessage(chatId,
      'ğŸ’ª Enter difficulty variants for <b>' + (state.habitName || 'this habit') + '</b>:\n\n' +
      'Format: <code>Easy / Medium / Hard / Peak</code>\n' +
      'Example: <code>10 min walk / 30 min walk / 5km run / 10km run</code>\n\n' +
      '(You can leave some blank â€” just use / as separator)'
    );
    setWaiting(telegramId, true);
    return;
  }


  // Normal organise flow
  const area = cq.data.replace('ORG_AREA:', '');
  state.pendingArea = area;
  setState(telegramId, state);
  askOrganiseStep(chatId, telegramId, 'horizon');
}


function handleOrganizeHorizon(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const horizon    = cq.data.replace('ORG_HORIZON:','');
  const state      = getState(telegramId);


  setWaiting(telegramId, false);
  state.pendingHorizon = horizon;
  setState(telegramId, state);
  askOrganiseStep(chatId, telegramId, 'type');
}


function handleOrganizeType(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const type       = cq.data.replace('ORG_TYPE:','');
  const state      = getState(telegramId);


  setWaiting(telegramId, false);
  state.pendingType = type;
  setState(telegramId, state);
  askOrganiseStep(chatId, telegramId, 'category');
}


function handleOrganizeCategory(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const category   = cq.data.replace('ORG_CAT:','');
  const state      = getState(telegramId);


  setWaiting(telegramId, false);


  // Commit this activity to Convex
  const item = state.queue[state.qIndex];
  const result = dbOrganizeActivity(item.id, {
    goalId:      state.pendingGoalId,
    incup:       state.pendingIncup || '',
    lifeArea:    state.pendingArea,
    horizon:     state.pendingHorizon,
    exeType:     state.pendingType || 'task',
    category:    category,
    mentalBlock: false
  });


  sendMessage(chatId, 'âœ… Organised! <b>+' + result.organiseXp + ' OrganiseXP</b>');


  // Clear pending fields, advance queue
  state.qIndex++;
  delete state.pendingGoalId; delete state.pendingIncup;
  delete state.pendingArea;   delete state.pendingHorizon;
  delete state.pendingType;
  setState(telegramId, state);
  presentOrganiseItem(chatId, telegramId);
}


function handleOrganizeDone(cq) {
  finishOrganise(cq.message.chat.id, String(cq.from.id));
}


function askOrganiseStep(chatId, telegramId, step) {
  const state = getState(telegramId);
  if (isWaiting(telegramId)) return;
  state.step = step;
  setState(telegramId, state);


  if (step === 'incup') {
    const buttons = INCUP_OPTIONS.map(function(opt) {
      return [{ text: opt, callback_data: 'ORG_INCUP:' + opt }];
    });
    buttons.push([{ text: 'âœ”ï¸ Done', callback_data: 'ORG_INCUP:DONE' }]);
    sendMessage(chatId, 'ğŸ—‚ï¸ <b>Step 2/7:</b> INCUP tags (tap to toggle):', { reply_markup: { inline_keyboard: buttons } });
    setWaiting(telegramId, true);
    return;
  }
  if (step === 'area') {
    sendMessage(chatId, 'ğŸ—‚ï¸ <b>Step 3/7:</b> Life Area:',
      inlineButtons([
        LIFE_AREAS.slice(0,4).map(function(a){ return { text: LIFE_AREA_LABELS[a] || a, callback_data: 'ORG_AREA:'+a }; }),
        LIFE_AREAS.slice(4).map(function(a){ return { text: LIFE_AREA_LABELS[a] || a, callback_data: 'ORG_AREA:'+a }; })
      ])
    );
    setWaiting(telegramId, true);
    return;
  }
  if (step === 'horizon') {
    sendMessage(chatId, 'ğŸ—‚ï¸ <b>Step 4/7:</b> Horizon:',
      inlineButtons([
        HORIZONS.slice(0,3).map(function(h){ return { text: h, callback_data: 'ORG_HORIZON:'+h }; }),
        HORIZONS.slice(3).map(function(h){ return { text: h, callback_data: 'ORG_HORIZON:'+h }; })
      ])
    );
    setWaiting(telegramId, true);
    return;
  }
  if (step === 'type') {
    sendMessage(chatId, 'ğŸ—‚ï¸ <b>Step 5/7:</b> Execution type:',
      inlineButtons([EXE_TYPES.map(function(t){ return { text: t, callback_data: 'ORG_TYPE:'+t }; })])
    );
    setWaiting(telegramId, true);
    return;
  }
  if (step === 'category') {
    sendMessage(chatId, 'ğŸ—‚ï¸ <b>Step 6/7:</b> Quest category:',
      inlineButtons([
        CATEGORIES.slice(0,2).map(function(c){ return { text: c, callback_data: 'ORG_CAT:'+c }; }),
        CATEGORIES.slice(2).map(function(c){ return { text: c, callback_data: 'ORG_CAT:'+c }; })
      ])
    );
    setWaiting(telegramId, true);
    return;
  }
}


function finishOrganise(chatId, telegramId) {
  dbMarkOrganizeDone(telegramId);
  clearState(telegramId);
  sendMessage(chatId,
    'ğŸ‰ Organising complete!\n\nWhat would you like to do next?',
    inlineButtons([[
      { text: 'âš”ï¸ Execute tasks',       callback_data: 'DO_FLOW' },
      { text: 'ğŸ“Š Evaluate done tasks',  callback_data: 'EVAL_FLOW' }
    ]])
  );
}


// â”€â”€â”€ Do / Evaluate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleDoFlow(msg) {
  const chatId     = msg.chat.id;
  const telegramId = msg.from ? String(msg.from.id) : '';
  const webAppUrl  = (PropertiesService.getScriptProperties().getProperty('MINI_APP_URL') || 'https://your-mini-app.example.com')
    + '?tab=do&userId=' + telegramId;
  sendWebAppButton(chatId, 'âš”ï¸ Open your quest list to execute tasks:', 'ğŸ—¡ï¸ Execute Quests', webAppUrl);
}


function handleEvaluateFlow(msg) {
  const chatId     = msg.chat.id;
  const telegramId = msg.from ? String(msg.from.id) : '';
  const webAppUrl  = (PropertiesService.getScriptProperties().getProperty('MINI_APP_URL') || 'https://your-mini-app.example.com')
    + '?tab=evaluate&userId=' + telegramId;
  sendWebAppButton(chatId, 'ğŸ“Š Open completed quests to evaluate:', 'ğŸ” Evaluate Quests', webAppUrl);
}


// â”€â”€â”€ Habits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function handleHabitsMenu(msg) {
  const chatId     = msg.chat.id;
  const telegramId = String(msg.from.id);
  const state      = getState(telegramId);
  const convexUserId = state.convexUserId || dbEnsureUser(telegramId);


  const habits = dbListHabits(convexUserId) || [];
  if (habits.length === 0) {
    sendMessage(chatId, 'ğŸ“¿ No habits yet. Let\'s create one!\nSend me the habit name:');
    setState(telegramId, { flow: 'habit_create', step: 'name', convexUserId: convexUserId });
    setWaiting(telegramId, true);
    return;
  }


  sendMessage(chatId, 'ğŸ“¿ <b>Your habits:</b>\n\n' +
    habits.map(function(h) { return 'â€¢ ' + h.name + ' ğŸ”¥' + h.currentStreak; }).join('\n') +
    '\n\nLog a completion:',
    inlineButtons(habits.slice(0,8).map(function(h) {
      return [{ text: h.name + ' ğŸ”¥' + h.currentStreak, callback_data: 'HABIT_LOG:' + h._id }];
    }))
  );
}


function handleHabitCreateReply(chatId, telegramId, text, state) {
  if (state.step === 'name') {
    state.habitName = text;
    state.step = 'lifeArea';
    setState(telegramId, state);
    sendMessage(chatId, 'Life area for this habit?',
      inlineButtons([
        LIFE_AREAS.slice(0,4).map(function(a){ return { text: LIFE_AREA_LABELS[a]||a, callback_data: 'ORG_AREA:habit:'+a }; }),
        LIFE_AREAS.slice(4).map(function(a){ return { text: LIFE_AREA_LABELS[a]||a, callback_data: 'ORG_AREA:habit:'+a }; })
      ])
    );
    setWaiting(telegramId, true);
    return;
  }
  if (state.step === 'variants') {
    const parts = text.split('/').map(function(t){ return t.trim(); });
    dbCreateHabit(state.convexUserId, {
      name:     state.habitName,
      lifeArea: state.habitLifeArea || 'mental',
      easy:     parts[0] || undefined,
      medium:   parts[1] || undefined,
      hard:     parts[2] || undefined,
      peak:     parts[3] || undefined
    });
    sendMessage(chatId, 'âœ… Habit "<b>' + state.habitName + '</b>" created! ğŸ”¥\nUse /habits to log completions.');
    clearState(telegramId);
  }
}


function handleHabitLog(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const habitDocId = cq.data.replace('HABIT_LOG:','');


  const state    = getState(telegramId);
  const convexUserId = state.convexUserId || dbEnsureUser(telegramId);
  const habits   = dbListHabits(convexUserId) || [];
  const habit    = habits.find(function(h){ return h._id === habitDocId; });
  if (!habit) { sendMessage(chatId, 'Habit not found.'); return; }


  const variants = [
    { label: habit.easy   || 'Easy',   key: 'easy' },
    { label: habit.medium || 'Medium', key: 'medium' },
    { label: habit.hard   || 'Hard',   key: 'hard' },
    { label: habit.peak   || 'Peak',   key: 'peak' }
  ].filter(function(v){ return v.label; });


  sendMessage(chatId, 'ğŸ’ª Logging <b>' + habit.name + '</b>\n\nSelect difficulty:',
    inlineButtons(variants.map(function(v) {
      return [{ text: v.label, callback_data: 'HABIT_DIFF:' + habitDocId + ':' + v.key }];
    }))
  );
}


function handleHabitDiff(cq) {
  const chatId     = cq.message.chat.id;
  const telegramId = String(cq.from.id);
  const parts      = cq.data.split(':');
  const habitDocId = parts[1];
  const diffKey    = parts[2]; // easy, medium, hard, peak


  const state    = getState(telegramId);
  const convexUserId = state.convexUserId || dbEnsureUser(telegramId);
  const habits   = dbListHabits(convexUserId) || [];
  const habit    = habits.find(function(h){ return h._id === habitDocId; });
  if (!habit) { sendMessage(chatId, 'Habit not found.'); return; }


  const result = dbLogHabit(habitDocId, diffKey);
  sendMessage(chatId,
    'âœ… <b>' + habit.name + '</b> logged! +' + result.habitXp + ' HabitXP\n' +
    'ğŸ”¥ Streak: ' + result.currentStreak
  );
}


// â”€â”€â”€ Daily summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function sendDailySummary(chatId, telegramId) {
  const summary = dbGetUserSummary(String(telegramId));
  if (!summary) { sendMessage(chatId, 'âš ï¸ No data found yet. Forward a message to get started!'); return; }


  sendMessage(chatId,
    'ğŸ“Š <b>Daily Summary</b>\n\n' +
    'âš”ï¸ Rank: <b>' + summary.rank + '</b> (Level ' + summary.level + ')\n' +
    'âœ¨ Total XP: <b>' + summary.totalXp + '</b>\n' +
    'ğŸ’ Chrysolite: <b>' + summary.chrysolite + '</b>\n' +
    'â¤ï¸ HP: <b>' + summary.hp + '/100</b>\n\n' +
    'ğŸ“‹ Captured: ' + summary.capturedCount + '  |  Ready: ' + summary.readyCount + '  |  Done: ' + summary.doneCount + '\n' +
    'ğŸ¯ Active goals: ' + summary.goalCount + '  |  Habits: ' + summary.habitCount + '\n\n' +
    'Keep going! ğŸ† â€” Noufeli'
  );
}


// â”€â”€â”€ Organise reminder trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function organiseReminderTrigger() {
  try {
    const users = dbListUsersWithPendingOrganize();
    if (!users || users.length === 0) return;


    users.forEach(function(user) {
      try {
        const telegramId = user.telegramId;
        const chatId     = user.settings && user.settings.chatId;
        if (!chatId) return;


        // Skip users who have never completed an organise session â€” this means
        // they set their interval during onboarding but haven't finished setup yet.
        // Without this guard the trigger fires immediately after interval is saved.
        const lastOrganizedAt = user.settings && user.settings.lastOrganizedAt;
        if (!lastOrganizedAt) return;


        // Skip if mid-conversation
        const state = dbGetState(telegramId);
        if (state && state.flow) {
          Logger.log('Skipping reminder for ' + telegramId + ' â€“ mid-conversation (flow: ' + state.flow + ')');
          return;
        }


        triggerOrganiseReminder(telegramId, chatId);
      } catch (e) {
        Logger.log('Reminder error for user ' + (user.telegramId || '?') + ': ' + e);
      }
    });
  } catch (e) {
    Logger.log('organiseReminderTrigger error: ' + e);
  }
}


function dailySummaryTrigger() {
  try {
    const users = convexQuery('users:listUsersWithPendingOrganize', {});
    // Re-use the same user list (all users with chatId set)
    const allUsers = convexQuery('users:getUserByTelegramId', {}) || [];
    // Actually fetch all users via a broad query â€” re-use organizeInterval list
    // as a proxy for "active users with chatId"
    const pending = dbListUsersWithPendingOrganize();
    if (!pending) return;


    pending.forEach(function(user) {
      const chatId = user.settings && user.settings.chatId;
      if (!chatId) return;
      const state = getState(user.telegramId);
      if (state && state.flow) return;
      try { sendDailySummary(chatId, user.telegramId); } catch(e) { Logger.log('Summary error: ' + e); }
    });
  } catch (e) {
    Logger.log('dailySummaryTrigger error: ' + e);
  }
}