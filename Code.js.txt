/**
 * Code.js  –  Noufeli Bot entry point
 * ─────────────────────────────────────────────────────────────────────────────
 * Script Properties required:
 *   BOT_TOKEN      – Telegram Bot token from BotFather
 *   CONVEX_URL     – Your Convex deployment URL, e.g. https://happy-animal-123.convex.cloud
 *   WEBAPP_URL     – This Apps Script Web App URL (set after first deploy)
 *   MINI_APP_URL   – Hosted Mini App URL
 *   WEBHOOK_SECRET – Random secret shared with Telegram (A-Z a-z 0-9 _ -)
 *                    Generate: crypto.randomUUID() in browser console
 *                    After adding, re-run setWebhook().
 * ─────────────────────────────────────────────────────────────────────────────
 */


// ---------------------------------------------------------------------------
// Config helpers
// ---------------------------------------------------------------------------


function getConfig(key) {
  const val = PropertiesService.getScriptProperties().getProperty(key);
  if (!val) throw new Error('Missing Script Property: ' + key);
  return val;
}


function getBotToken()  { return getConfig('BOT_TOKEN'); }
function getWebAppUrl() { return getConfig('WEBAPP_URL'); }


// ---------------------------------------------------------------------------
// Webhook secret verification
// ---------------------------------------------------------------------------
// NOTE: Google Apps Script does NOT expose HTTP headers in doPost(e).
// Telegram sends the secret in X-Telegram-Bot-Api-Secret-Token header,
// which we cannot read here. So when WEBHOOK_SECRET is set, we cannot verify.
// Options: (1) Leave WEBHOOK_SECRET unset for Apps Script, or
// (2) Use a different host (e.g. Cloud Functions) that exposes headers.
// For now we allow through when we cannot read the header (incoming empty).
// ---------------------------------------------------------------------------


function verifyWebhookSecret(e, body) {
  const secret = PropertiesService.getScriptProperties().getProperty('WEBHOOK_SECRET');
  if (!secret) {
    return true;
  }
  // Apps Script e.parameter only has query params, NOT headers.
  // Some platforms might pass headers with a prefix – check common variants.
  const incoming =
    (e.parameter && (e.parameter['x-telegram-bot-api-secret-token'] ||
     e.parameter['X-Telegram-Bot-Api-Secret-Token'])) || '';

  if (incoming && incoming !== secret) {
    Logger.log('Webhook secret mismatch – rejected.');
    return false;
  }
  // When incoming is empty: either Apps Script (can't read headers) or no header sent.
  // Allow through if the body looks like a valid Telegram update (weak verification).
  if (!incoming && body && typeof body.update_id === 'number') {
    Logger.log('WEBHOOK_SECRET set but headers not readable (Apps Script) – allowing valid update.');
    return true;
  }
  if (!incoming) {
    Logger.log('WEBHOOK_SECRET set but no secret in request – rejected.');
    return false;
  }
  return true;
}


// ---------------------------------------------------------------------------
// Main HTTP handlers
// ---------------------------------------------------------------------------


function doPost(e) {
  try {
    const body = JSON.parse(e.postData.contents);


    if (body.update_id !== undefined) {
      if (!verifyWebhookSecret(e, body)) {
        return ContentService
          .createTextOutput(JSON.stringify({ error: 'Forbidden' }))
          .setMimeType(ContentService.MimeType.JSON);
      }
      return handleTelegramUpdate(body);
    }


    // Mini App API calls – routed by ?path= query param
    const path = e.parameter.path || '';
    return handleApiPost(path, body, e.parameter);


  } catch (err) {
    Logger.log('doPost error: ' + err + '\n' + err.stack);
    return ContentService.createTextOutput(JSON.stringify({ error: err.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}


function doGet(e) {
  try {
    const path = e.parameter.path || '';
    return handleApiGet(path, e.parameter);
  } catch (err) {
    Logger.log('doGet error: ' + err);
    return jsonResponse({ error: err.message });
  }
}


function jsonResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}